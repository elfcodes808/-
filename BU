-- Robust Kick Hook to prevent client-side kicks
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Try overriding Kick directly on the player's metatable
if LocalPlayer and LocalPlayer.Kick then
    local success, err = pcall(function()
        local mt = getrawmetatable(LocalPlayer)
        if mt and setreadonly then
            setreadonly(mt, false)
            mt.Kick = function() 
                warn("[ShadowZ Hub] Kick blocked by direct override!") 
                -- block kick
            end
            setreadonly(mt, true)
        else
            -- fallback: override method on the object itself (less effective)
            LocalPlayer.Kick = function() 
                warn("[ShadowZ Hub] Kick blocked by method override!") 
            end
        end
    end)
    if not success then
        warn("Failed to hook Kick directly: " .. tostring(err))
    end
end

-- Backup hook using hookfunction (if supported)
if hookfunction and LocalPlayer.Kick then
    local originalKick = LocalPlayer.Kick
    hookfunction(originalKick, function(...)
        warn("[ShadowZ Hub] Kick blocked by hookfunction!")
        return
    end)
end

-- Backup hook using __namecall metamethod override
local mt = getrawmetatable(game)
if mt and setreadonly then
    setreadonly(mt, false)
    local oldNamecall = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if self == LocalPlayer and method == "Kick" then
            warn("[ShadowZ Hub] Kick blocked by __namecall hook!")
            return
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)
end

-- Load Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Custom UI Load Message
Rayfield:Notify({
    Title = "Baseball Universe | ShadowZ",
    Content = "UI Loaded Successfully",
    Duration = 4
})

-- UI Setup
local Window = Rayfield:CreateWindow({
    Name = "Baseball Universe | ShadowZ Hub",
    ConfigurationSaving = {
        Enabled = false
    }
})

local BattingTab = Window:CreateTab("Batting", 4483362458)
local FieldingTab = Window:CreateTab("Fielding", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

-- Vars
local player = LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

local Settings = {
    AutoAim = false,
    ShowDot = false,
    AutoHitDelay = 0.25,
    FlyEnabled = false
}

-- Ball ESP
local ballESP = Instance.new("Part")
ballESP.Shape = Enum.PartType.Ball
ballESP.Size = Vector3.new(0.7, 0.7, 0.7)
ballESP.Anchored = true
ballESP.CanCollide = false
ballESP.Material = Enum.Material.SmoothPlastic
ballESP.Color = Color3.fromRGB(0, 170, 255)
ballESP.Transparency = 0.25
ballESP.Name = "BallESP"
ballESP.Position = Vector3.new(9999,9999,9999)
ballESP.Parent = workspace

-- Batting Tab UI
BattingTab:CreateToggle({
    Name = "Ball ESP",
    CurrentValue = false,
    Callback = function(Value)
        Settings.ShowDot = Value
    end
})

BattingTab:CreateToggle({
    Name = "Auto Aim",
    CurrentValue = false,
    Callback = function(Value)
        Settings.AutoAim = Value
    end
})

BattingTab:CreateSlider({
    Name = "Auto Hit Delay",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "s",
    CurrentValue = Settings.AutoHitDelay,
    Callback = function(Value)
        Settings.AutoHitDelay = Value
    end
})

BattingTab:CreateToggle({
    Name = "Auto Hit (Coming Soon)",
    CurrentValue = false,
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Coming Soon",
            Content = "Auto Hit will be available in the next update!",
            Duration = 4
        })
    end
})

-- Fielding Tab
FieldingTab:CreateToggle({
    Name = "Perfect Accuracy (Coming Soon)",
    CurrentValue = false,
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Coming Soon",
            Content = "Perfect Accuracy feature is still being developed!",
            Duration = 4
        })
    end
})

-- Misc Tab
MiscTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {16, 50},
    Increment = 1,
    CurrentValue = 16,
    Callback = function(value)
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = value
        end
    end
})

-- Fly Toggle
MiscTab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Callback = function(Value)
        Settings.FlyEnabled = Value
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        local hrp = character.HumanoidRootPart

        if Value then
            -- Disable gravity and allow flying movement
            local BodyVelocity = Instance.new("BodyVelocity")
            BodyVelocity.Name = "FlyBodyVelocity"
            BodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
            BodyVelocity.Velocity = Vector3.new(0,0,0)
            BodyVelocity.Parent = hrp

            local BodyGyro = Instance.new("BodyGyro")
            BodyGyro.Name = "FlyBodyGyro"
            BodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
            BodyGyro.CFrame = hrp.CFrame
            BodyGyro.Parent = hrp

            -- Control flying with keys
            local UserInputService = game:GetService("UserInputService")

            local connection
            connection = game:GetService("RunService").RenderStepped:Connect(function()
                if not Settings.FlyEnabled then
                    if BodyVelocity then BodyVelocity:Destroy() end
                    if BodyGyro then BodyGyro:Destroy() end
                    connection:Disconnect()
                    return
                end

                local direction = Vector3.new(0,0,0)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    direction = direction + (camera.CFrame.LookVector)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    direction = direction - (camera.CFrame.LookVector)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    direction = direction + Vector3.new(0,1,0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    direction = direction - Vector3.new(0,1,0)
                end

                BodyVelocity.Velocity = direction * 50
                BodyGyro.CFrame = camera.CFrame
            end)
        else
            -- Disable fly by destroying the BodyVelocity and BodyGyro
            if hrp:FindFirstChild("FlyBodyVelocity") then
                hrp.FlyBodyVelocity:Destroy()
            end
            if hrp:FindFirstChild("FlyBodyGyro") then
                hrp.FlyBodyGyro:Destroy()
            end
        end
    end
})

-- TP to Mound button
MiscTab:CreateButton({
    Name = "TP to Mound",
    Callback = function()
        local mound = workspace.Repository.Infield:FindFirstChild("Mound")
        if mound and mound:IsA("BasePart") then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = mound.CFrame + Vector3.new(0, 5, 0) -- teleport slightly above mound to avoid falling through
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "You have been teleported to the mound.",
                    Duration = 3
                })
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Character or HumanoidRootPart not found.",
                    Duration = 3
                })
            end
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Mound not found in workspace.Repository.Infield.",
                Duration = 3
            })
        end
    end
})

-- Pitch Event Prediction Logic
local pitchEvent = game:GetService("ReplicatedStorage").Packages.Knit.Services.PitchingService.RE.Pitch

pitchEvent.OnClientEvent:Connect(function(...)
    local args = {...}
    for _, v in pairs(args) do
        if typeof(v) == "table" and v[4] then
            local finalPos = v[4]
            local predictedPos = finalPos + Vector3.new(0, 0, -Settings.AutoHitDelay * 60)

            local inBatBox = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and
                (player.Character.HumanoidRootPart.Position - finalPos).Magnitude <= 10

            if Settings.ShowDot and inBatBox then
                ballESP.Position = Vector3.new(finalPos.X - 0.33, finalPos.Y + 0.47, 112.6)
            else
                ballESP.Position = Vector3.new(9999, 9999, 9999)
            end

            if Settings.AutoAim and inBatBox then
                local screenPos, onScreen = camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local dx = screenPos.X - (camera.ViewportSize.X / 2)
                    local dy = screenPos.Y - (camera.ViewportSize.Y / 2)
                    mousemoverel(dx, dy)
                end
            end
        end
    end
end)
